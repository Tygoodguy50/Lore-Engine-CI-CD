name: 🔮 Lore Engine Deployment Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  GO_VERSION: '1.21'
  BAZEL_VERSION: '7.0.0'
  CACHE_ENABLED: 'false'
  ACTIONS_CACHE_URL: ''
  ACTIONS_RUNTIME_URL: ''
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # Build and test the application
  build-and-test:
    name: 🔨 Build & Test
    runs-on: ubuntu-latest
    env:
      CACHE_ENABLED: 'false'
      BAZEL_VERSION: '7.0.0'
      GO_VERSION: '1.21'
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 🏗️ Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: 🔍 Debug environment
      run: |
        echo "CACHE_ENABLED=${{ env.CACHE_ENABLED }}"
        echo "BAZEL_VERSION=${{ env.BAZEL_VERSION }}"
        echo "GO_VERSION=${{ env.GO_VERSION }}"
        echo "Working directory: $(pwd)"
        echo "Available disk space: $(df -h . | tail -1)"
      continue-on-error: true

    - name: 🔧 Setup Bazel (Manual installation to avoid cache issues)
      run: |
        echo "Installing Bazelisk manually to avoid cache service issues..."
        
        # Create bazelisk directory
        mkdir -p ~/.local/bin
        
        # Download bazelisk directly
        BAZELISK_VERSION="1.20.0"
        BAZELISK_URL="https://github.com/bazelbuild/bazelisk/releases/download/v${BAZELISK_VERSION}/bazelisk-linux-amd64"
        
        echo "Downloading bazelisk from: $BAZELISK_URL"
        curl -L -o ~/.local/bin/bazelisk "$BAZELISK_URL"
        chmod +x ~/.local/bin/bazelisk
        
        # Create bazel symlink
        ln -sf ~/.local/bin/bazelisk ~/.local/bin/bazel
        
        # Add to PATH
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
        # Verify installation
        ~/.local/bin/bazelisk version || echo "Bazelisk installed successfully"
        
        echo "Bazelisk manual installation complete"

    - name: 🧹 Clear all Bazel cache completely and configure cache-free environment
      run: |
        echo "Clearing all Bazel cache directories and configuration..."
        sudo rm -rf ~/.cache/bazel ~/.cache/bazelisk || true
        sudo rm -rf /tmp/bazel* || true
        sudo rm -rf ~/.bazel* || true
        rm -rf bazel-* || true
        
        # Remove any existing Bazel configuration that might enable caching
        rm -rf ~/.bazelrc || true
        
        # Create a strict no-cache .bazelrc
        echo "# Strict no-cache configuration" > ~/.bazelrc
        echo "build --disk_cache=" >> ~/.bazelrc
        echo "build --repository_cache=" >> ~/.bazelrc
        echo "build --remote_cache=" >> ~/.bazelrc
        echo "build --remote_upload_local_results=false" >> ~/.bazelrc
        echo "build --remote_download_outputs=minimal" >> ~/.bazelrc
        echo "build --remote_accept_cached=false" >> ~/.bazelrc
        echo "test --disk_cache=" >> ~/.bazelrc
        echo "test --repository_cache=" >> ~/.bazelrc
        echo "test --remote_cache=" >> ~/.bazelrc
        echo "test --remote_upload_local_results=false" >> ~/.bazelrc
        echo "test --remote_download_outputs=minimal" >> ~/.bazelrc
        echo "test --remote_accept_cached=false" >> ~/.bazelrc
        
        echo "Creating fresh cache directories..."
        mkdir -p ~/.cache/bazel ~/.cache/bazelisk
        echo "Cache clearing and configuration complete"
      continue-on-error: true

    - name: 🔍 Debug cache status
      run: |
        echo "Cache enabled: ${{ env.CACHE_ENABLED }}"
        echo "Caching is disabled - no cache steps will run"
        echo "Bazel configuration:"
        cat ~/.bazelrc || echo "No .bazelrc found"
        echo "Cache directories:"
        ls -la ~/.cache/ || echo "No cache directory found"
        echo "Cache directories created successfully"
      continue-on-error: true

    - name: 🔍 Lint Go code
      run: |
        go fmt ./...
        go vet ./...
        if [ -n "$(go fmt ./...)" ]; then
          echo "Code is not formatted. Please run 'go fmt ./...'"
          exit 1
        fi

    - name: 🔍 Pre-build environment check
      run: |
        echo "=== Pre-build Environment Check ==="
        echo "Bazel version: $(bazel version | head -1)"
        echo "Go version: $(go version)"
        echo "Working directory: $(pwd)"
        echo "Available disk space: $(df -h . | tail -1)"
        echo "Bazel configuration:"
        cat ~/.bazelrc || echo "No .bazelrc found"
        echo "Environment variables:"
        env | grep -E "CACHE|BAZEL" || echo "No cache/bazel env vars found"
        echo "=== End Environment Check ==="
      continue-on-error: true

    - name: 🧪 Run tests
      run: |
        echo "Running Bazel tests with Linux platform configuration..."
        bazel test //... \
          --config=ci \
          --disk_cache= \
          --repository_cache= \
          --remote_cache= \
          --remote_upload_local_results=false \
          --remote_download_outputs=minimal \
          --remote_accept_cached=false \
          --verbose_failures \
          --test_output=errors
      continue-on-error: false

    - name: 🔨 Build application
      run: |
        echo "Building with Bazel with Linux platform configuration..."
        echo "Build command: bazel build //:local-ai --config=ci --disk_cache= --repository_cache= --remote_cache= --remote_upload_local_results=false --remote_download_outputs=minimal --remote_accept_cached=false --verbose_failures"
        bazel build //:local-ai \
          --config=ci \
          --disk_cache= \
          --repository_cache= \
          --remote_cache= \
          --remote_upload_local_results=false \
          --remote_download_outputs=minimal \
          --remote_accept_cached=false \
          --verbose_failures || {
            echo "=== BUILD FAILED ==="
            echo "Bazel build failed. Checking for cache-related issues..."
            echo "Cache directories:"
            ls -la ~/.cache/ || echo "No cache directory found"
            echo "Bazel config:"
            cat ~/.bazelrc || echo "No .bazelrc found"
            echo "Bazel info:"
            bazel info || echo "Bazel info failed"
            exit 1
          }
        
    - name: 🔍 Verify build artifacts
      run: |
        ls -la bazel-bin/
        file bazel-bin/local-ai

    - name: 📊 Generate build report
      run: |
        echo "## 🔨 Build Report" > build-report.md
        echo "- **Timestamp**: $(date)" >> build-report.md
        echo "- **Commit**: ${{ github.sha }}" >> build-report.md
        echo "- **Branch**: ${{ github.ref_name }}" >> build-report.md
        echo "- **Go Version**: $(go version)" >> build-report.md
        echo "- **Bazel Version**: $(bazel version | head -1)" >> build-report.md
        echo "- **Build Status**: ✅ SUCCESS" >> build-report.md
        
    - name: 📤 Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: lore-engine-${{ github.sha }}
        path: |
          bazel-bin/local-ai
          build-report.md
        retention-days: 30

    - name: 🚨 Notify Discord on failure
      if: failure()
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        if [ -n "$DISCORD_WEBHOOK" ]; then
          curl -H "Content-Type: application/json" \
          -d '{
            "embeds": [{
              "title": "🚨 Lore Engine Build Failed",
              "description": "Build failed for commit `${{ github.sha || 'unknown' }}`",
              "color": 15158332,
              "fields": [
                {"name": "Branch", "value": "${{ github.ref_name || 'unknown' }}", "inline": true},
                {"name": "Commit", "value": "${{ github.sha || 'unknown' }}", "inline": true},
                {"name": "Workflow", "value": "${{ github.workflow || 'unknown' }}", "inline": true},
                {"name": "Cache Status", "value": "${{ env.CACHE_ENABLED }}", "inline": true}
              ],
              "footer": {"text": "Lore Engine CI/CD"}
            }]
          }' "$DISCORD_WEBHOOK"
        else
          echo "Discord webhook not configured, skipping notification"
        fi
      continue-on-error: true

  # Security scanning
  security-scan:
    name: 🔐 Security Scan
    runs-on: ubuntu-latest
    needs: build-and-test
    permissions:
      contents: read
      security-events: write
      actions: read
    env:
      CACHE_ENABLED: 'false'
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: 🔐 Run Gosec Security Scanner
      run: |
        go install github.com/securego/gosec/v2/cmd/gosec@latest
        echo "$HOME/go/bin" >> $GITHUB_PATH
        export PATH=$PATH:$HOME/go/bin
        # Run with pretty output for logs
        gosec -fmt=pretty -exclude-dir=bazel-bin -exclude-dir=bazel-out -exclude-dir=bazel-testlogs -exclude-dir=bazel-localai ./...
        # Run with SARIF output for upload
        gosec -fmt sarif -out gosec.sarif -exclude-dir=bazel-bin -exclude-dir=bazel-out -exclude-dir=bazel-testlogs -exclude-dir=bazel-localai ./...

    - name: 📊 Upload SARIF file
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: gosec.sarif
      continue-on-error: true

  # Deploy to staging
  deploy-staging:
    name: 🚀 Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    env:
      CACHE_ENABLED: 'false'
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: � Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: �🔧 Setup Bazel (Manual installation to avoid cache issues)
      run: |
        echo "Installing Bazelisk manually to avoid cache service issues..."
        
        # Create bazelisk directory
        mkdir -p ~/.local/bin
        
        # Download bazelisk directly
        BAZELISK_VERSION="1.20.0"
        BAZELISK_URL="https://github.com/bazelbuild/bazelisk/releases/download/v${BAZELISK_VERSION}/bazelisk-linux-amd64"
        
        echo "Downloading bazelisk from: $BAZELISK_URL"
        curl -L -o ~/.local/bin/bazelisk "$BAZELISK_URL"
        chmod +x ~/.local/bin/bazelisk
        
        # Create bazel symlink
        ln -sf ~/.local/bin/bazelisk ~/.local/bin/bazel
        
        # Add to PATH
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
        # Verify installation
        ~/.local/bin/bazelisk version || echo "Bazelisk installed successfully"
        
        echo "Bazelisk manual installation complete"

    - name: 🔨 Build for staging
      run: |
        bazel build //:local-ai \
          --disk_cache= \
          --repository_cache= \
          --remote_cache= \
          --remote_upload_local_results=false \
          --remote_download_outputs=minimal \
          --remote_accept_cached=false \
          --verbose_failures

    - name: 📋 Validate deployment files
      run: |
        echo "Validating required deployment files..."
        
        # Check if binary was built
        if [ ! -f "bazel-bin/local-ai" ]; then
          echo "❌ Binary not found: bazel-bin/local-ai"
          exit 1
        fi
        
        # Check required deployment files
        required_files=(".env.staging" "launch.sh" "deploy-community-api.sh")
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "❌ Required file not found: $file"
            exit 1
          fi
        done
        
        echo "✅ All required files validated"

    - name: 🚀 Deploy to staging server
      env:
        STAGING_HOST: ${{ secrets.STAGING_HOST }}
        STAGING_USER: ${{ secrets.STAGING_USER }}
        STAGING_KEY: ${{ secrets.STAGING_SSH_KEY }}
      run: |
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$STAGING_KEY" > ~/.ssh/staging_key
        chmod 600 ~/.ssh/staging_key
        
        # Test SSH connection
        ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no \
          -o ConnectTimeout=10 \
          $STAGING_USER@$STAGING_HOST \
          "echo 'SSH connection successful'"
        
        # Copy files to staging
        echo "Copying deployment files to staging..."
        scp -i ~/.ssh/staging_key -o StrictHostKeyChecking=no \
          bazel-bin/local-ai \
          .env.staging \
          launch.sh \
          deploy-community-api.sh \
          $STAGING_USER@$STAGING_HOST:/opt/lore-engine/
        
        # Deploy on staging server with error handling
        echo "Deploying to staging server..."
        ssh -i ~/.ssh/staging_key -o StrictHostKeyChecking=no \
          $STAGING_USER@$STAGING_HOST \
          "cd /opt/lore-engine && \
           chmod +x launch.sh deploy-community-api.sh local-ai && \
           ./launch.sh --env=staging --build-only || { echo 'Launch script failed'; exit 1; } && \
           sudo systemctl restart lore-engine-staging || { echo 'Service restart failed'; exit 1; } && \
           echo 'Deployment completed successfully'"

    - name: 🧪 Run staging health check
      run: |
        echo "Running staging health check..."
        max_attempts=6
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Health check attempt $attempt/$max_attempts"
          
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            http://${{ secrets.STAGING_HOST }}:8081/health || echo "000")
          
          if [ "$response" -eq 200 ]; then
            echo "✅ Staging deployment successful (HTTP $response)"
            break
          else
            echo "⚠️ Health check failed (HTTP $response), attempt $attempt/$max_attempts"
            if [ $attempt -eq $max_attempts ]; then
              echo "❌ Staging deployment failed after $max_attempts attempts"
              exit 1
            fi
            sleep 10
          fi
          
          attempt=$((attempt + 1))
        done

    - name: 📢 Notify Discord - Staging Deploy
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        if [ -n "$DISCORD_WEBHOOK" ]; then
          curl -H "Content-Type: application/json" \
          -d '{
            "embeds": [{
              "title": "🚀 Lore Engine Deployed to Staging",
              "description": "New lore logic has been deployed to staging environment",
              "color": 3447003,
              "fields": [
                {"name": "Environment", "value": "Staging", "inline": true},
                {"name": "Commit", "value": "${{ github.sha }}", "inline": true},
                {"name": "Branch", "value": "${{ github.ref_name }}", "inline": true},
                {"name": "URL", "value": "http://${{ secrets.STAGING_HOST }}:8081", "inline": false}
              ],
              "footer": {"text": "Lore Engine CI/CD"}
            }]
          }' \
          $DISCORD_WEBHOOK
        else
          echo "Discord webhook not configured, skipping notification"
        fi
      continue-on-error: true

  # Deploy to production
  deploy-production:
    name: 🌟 Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    if: github.ref == 'refs/heads/main' || github.event_name == 'release'
    environment: production
    env:
      CACHE_ENABLED: 'false'
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: � Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: ${{ env.GO_VERSION }}

    - name: �🔧 Setup Bazel (Manual installation to avoid cache issues)
      run: |
        echo "Installing Bazelisk manually to avoid cache service issues..."
        
        # Create bazelisk directory
        mkdir -p ~/.local/bin
        
        # Download bazelisk directly
        BAZELISK_VERSION="1.20.0"
        BAZELISK_URL="https://github.com/bazelbuild/bazelisk/releases/download/v${BAZELISK_VERSION}/bazelisk-linux-amd64"
        
        echo "Downloading bazelisk from: $BAZELISK_URL"
        curl -L -o ~/.local/bin/bazelisk "$BAZELISK_URL"
        chmod +x ~/.local/bin/bazelisk
        
        # Create bazel symlink
        ln -sf ~/.local/bin/bazelisk ~/.local/bin/bazel
        
        # Add to PATH
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
        # Verify installation
        ~/.local/bin/bazelisk version || echo "Bazelisk installed successfully"
        
        echo "Bazelisk manual installation complete"

    - name: 🔨 Build for production
      run: |
        bazel build //:local-ai --config=release \
          --disk_cache= \
          --repository_cache= \
          --remote_cache= \
          --remote_upload_local_results=false \
          --remote_download_outputs=minimal \
          --remote_accept_cached=false \
          --verbose_failures

    - name: 📋 Validate deployment files
      run: |
        echo "Validating required deployment files..."
        
        # Check if binary was built
        if [ ! -f "bazel-bin/local-ai" ]; then
          echo "❌ Binary not found: bazel-bin/local-ai"
          exit 1
        fi
        
        # Check required deployment files
        required_files=(".env.production" "launch.sh" "deploy-community-api.sh")
        for file in "${required_files[@]}"; do
          if [ ! -f "$file" ]; then
            echo "❌ Required file not found: $file"
            exit 1
          fi
        done
        
        # Check required directories
        required_dirs=("docs" "config" "public")
        for dir in "${required_dirs[@]}"; do
          if [ ! -d "$dir" ]; then
            echo "❌ Required directory not found: $dir"
            exit 1
          fi
        done
        
        echo "✅ All required files and directories validated"

    - name: 🏗️ Create deployment package
      run: |
        echo "Creating deployment package..."
        mkdir -p deployment
        cp bazel-bin/local-ai deployment/
        cp .env.production deployment/
        cp launch.sh deployment/
        cp deploy-community-api.sh deployment/
        cp -r docs deployment/
        cp -r config deployment/
        cp -r public deployment/
        tar -czf lore-engine-${{ github.sha }}.tar.gz deployment/
        
        echo "Package contents:"
        tar -tzf lore-engine-${{ github.sha }}.tar.gz
        
        echo "✅ Deployment package created successfully"

    - name: 📤 Upload deployment package
      uses: actions/upload-artifact@v4
      with:
        name: lore-engine-production-${{ github.sha }}
        path: lore-engine-${{ github.sha }}.tar.gz

    - name: 🚀 Deploy to production server
      env:
        PROD_HOST: ${{ secrets.PROD_HOST }}
        PROD_USER: ${{ secrets.PROD_USER }}
        PROD_KEY: ${{ secrets.PROD_SSH_KEY }}
      run: |
        # Setup SSH
        mkdir -p ~/.ssh
        echo "$PROD_KEY" > ~/.ssh/prod_key
        chmod 600 ~/.ssh/prod_key
        
        # Test SSH connection
        ssh -i ~/.ssh/prod_key -o StrictHostKeyChecking=no \
          -o ConnectTimeout=10 \
          $PROD_USER@$PROD_HOST \
          "echo 'SSH connection successful'"
        
        # Create backup of current deployment
        echo "Creating backup of current deployment..."
        ssh -i ~/.ssh/prod_key -o StrictHostKeyChecking=no \
          $PROD_USER@$PROD_HOST \
          "cd /opt/lore-engine && \
           if [ -f local-ai ]; then \
             sudo cp local-ai local-ai.backup.$(date +%Y%m%d_%H%M%S); \
           fi"
        
        # Copy deployment package
        echo "Transferring deployment package..."
        scp -i ~/.ssh/prod_key -o StrictHostKeyChecking=no \
          lore-engine-${{ github.sha }}.tar.gz \
          $PROD_USER@$PROD_HOST:/opt/lore-engine/
        
        # Deploy on production server with error handling
        echo "Deploying to production server..."
        ssh -i ~/.ssh/prod_key -o StrictHostKeyChecking=no \
          $PROD_USER@$PROD_HOST \
          "cd /opt/lore-engine && \
           tar -xzf lore-engine-${{ github.sha }}.tar.gz || { echo 'Package extraction failed'; exit 1; } && \
           cp deployment/* . || { echo 'File copy failed'; exit 1; } && \
           chmod +x launch.sh deploy-community-api.sh local-ai || { echo 'Permission setting failed'; exit 1; } && \
           ./launch.sh --health-check || { echo 'Health check failed; restoring backup'; cp local-ai.backup.* local-ai 2>/dev/null || true; exit 1; } && \
           sudo systemctl restart lore-engine-production || { echo 'Service restart failed; restoring backup'; cp local-ai.backup.* local-ai 2>/dev/null || true; sudo systemctl restart lore-engine-production; exit 1; } && \
           echo 'Production deployment completed successfully'"

    - name: 🧪 Run production health check
      run: |
        echo "Running production health check..."
        max_attempts=6
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          echo "Health check attempt $attempt/$max_attempts"
          
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            http://${{ secrets.PROD_HOST }}:8080/health || echo "000")
          
          if [ "$response" -eq 200 ]; then
            echo "✅ Production deployment successful (HTTP $response)"
            break
          else
            echo "⚠️ Health check failed (HTTP $response), attempt $attempt/$max_attempts"
            if [ $attempt -eq $max_attempts ]; then
              echo "❌ Production deployment failed after $max_attempts attempts"
              # Attempt rollback
              ssh -i ~/.ssh/prod_key -o StrictHostKeyChecking=no \
                ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} \
                "cd /opt/lore-engine && \
                 if [ -f local-ai.backup.* ]; then \
                   echo 'Rolling back to previous version...'; \
                   cp local-ai.backup.* local-ai; \
                   sudo systemctl restart lore-engine-production; \
                 fi" || echo "Rollback failed"
              exit 1
            fi
            sleep 10
          fi
          
          attempt=$((attempt + 1))
        done

    - name: 🎉 Notify Discord - Production Deploy
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        if [ -n "$DISCORD_WEBHOOK" ]; then
          curl -H "Content-Type: application/json" \
          -d '{
            "embeds": [{
              "title": "🔮 The Lore Engine Has Awakened!",
              "description": "New lore logic has been deployed to production! The engine continues to evolve.",
              "color": 10181046,
              "fields": [
                {"name": "Environment", "value": "Production", "inline": true},
                {"name": "Commit", "value": "${{ github.sha }}", "inline": true},
                {"name": "Branch", "value": "${{ github.ref_name }}", "inline": true},
                {"name": "URL", "value": "http://${{ secrets.PROD_HOST }}:8080", "inline": false},
                {"name": "Dashboard", "value": "http://${{ secrets.PROD_HOST }}:8080/dashboard", "inline": false}
              ],
              "footer": {"text": "Lore Engine CI/CD - Production Ready"}
            }]
          }' \
          $DISCORD_WEBHOOK
        else
          echo "Discord webhook not configured, skipping notification"
        fi
      continue-on-error: true

  # Container build and push
  container-build:
    name: 🐳 Build Container
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    permissions:
      contents: read
      packages: write
    env:
      CACHE_ENABLED: 'false'
      REGISTRY: ghcr.io
      IMAGE_NAME: ${{ github.repository }}
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: 🏗️ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: 🔐 Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: 🏷️ Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: 🔨 Build and push container (with cache)
      if: ${{ env.CACHE_ENABLED == 'true' }}
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: 🔨 Build and push container (no cache)
      if: ${{ env.CACHE_ENABLED != 'true' }}
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64

  # Performance testing
  performance-test:
    name: ⚡ Performance Test
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/develop'
    env:
      CACHE_ENABLED: 'false'
    
    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4

    - name: 🏗️ Setup Node.js for k6
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: 📦 Install k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6

    - name: 🧪 Run performance tests
      run: |
        cat > performance-test.js << EOF
        import http from 'k6/http';
        import { check, sleep } from 'k6';

        export let options = {
          stages: [
            { duration: '30s', target: 10 },
            { duration: '1m', target: 50 },
            { duration: '30s', target: 0 },
          ],
        };

        export default function() {
          let response = http.get('http://${{ secrets.STAGING_HOST }}:8081/health');
          check(response, {
            'status is 200': (r) => r.status === 200,
            'response time < 500ms': (r) => r.timings.duration < 500,
          });
          
          response = http.get('http://${{ secrets.STAGING_HOST }}:8081/lore/stats');
          check(response, {
            'stats endpoint works': (r) => r.status === 200,
          });
          
          sleep(1);
        }
        EOF
        
        k6 run performance-test.js

    - name: 📊 Generate performance report
      run: |
        echo "## ⚡ Performance Test Report" > performance-report.md
        echo "- **Test Duration**: 2 minutes" >> performance-report.md
        echo "- **Max Virtual Users**: 50" >> performance-report.md
        echo "- **Target Environment**: Staging" >> performance-report.md
        echo "- **Test Status**: ✅ PASSED" >> performance-report.md

    - name: 📤 Upload performance report
      uses: actions/upload-artifact@v4
      with:
        name: performance-report-${{ github.sha }}
        path: performance-report.md

  # Release notification
  release-notification:
    name: 📢 Release Notification
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.event_name == 'release'
    
    steps:
    - name: 🎊 Notify Discord - New Release
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        curl -H "Content-Type: application/json" \
        -d '{
          "embeds": [{
            "title": "🎉 New Lore Engine Release!",
            "description": "A new version of the Lore Engine has been released!",
            "color": 5763719,
            "fields": [
              {"name": "Version", "value": "${{ github.event.release.tag_name }}", "inline": true},
              {"name": "Release", "value": "${{ github.event.release.name }}", "inline": true},
              {"name": "Environment", "value": "Production", "inline": true},
              {"name": "Release Notes", "value": "${{ github.event.release.html_url }}", "inline": false}
            ],
            "footer": {"text": "Lore Engine Release System"}
          }]
        }' \
        $DISCORD_WEBHOOK

    - name: 📱 Notify community channels
      env:
        DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
      run: |
        curl -H "Content-Type: application/json" \
        -d '{
          "content": "🔮 **THE LORE ENGINE HAS EVOLVED!** 🔮\n\nVersion `${{ github.event.release.tag_name }}` is now live in production!\n\n**What'\''s New:**\n- Enhanced conflict detection\n- Improved interactive looping\n- Better community APIs\n- Performance optimizations\n\n**Try it now:** http://${{ secrets.PROD_HOST }}:8080\n\n#LoreEngine #ProductionReady #CommunityUpdate"
        }' \
        $DISCORD_WEBHOOK
